@page "/components/drag-drop"

<PageTitle>Drag-Drop - Tavenem Blazor Framework</PageTitle>

<Heading Level="HeadingLevel.H1">Drag-Drop</Heading>

<p>
    The Tavenem Blazor Framework provides some utility components to make interop with the <a
    href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">HTML5 drag and
    drop API</a> easier from your Blazor apps.
</p>

<Collapse Class="outlined mb-3" BodyClass="codeblock pre-razor-code">
    <TitleContent>
        <div class="row align-items-center justify-content-center">
            <DropTarget TDropItem="string" Class="flex-grow-1 align-self-stretch bg-alt p-2 rounded" OnDrop="@(e => Drop(_items1, e))">
                <h6>Drop Target 1</h6>
                @foreach (var item in _items1)
                {
                    <Draggable Item="item" OnDropped="@(e => Drag(_items1, item, e))" DragEffectAllowed="DragEffect.CopyMove">@item</Draggable>
                }
            </DropTarget>
            <DropTarget TDropItem="string" Class="flex-grow-1 align-self-stretch bg-alt p-2 rounded ms-3" OnDrop="@(e => Drop(_items2, e))">
                <h6>Drop Target 2</h6>
                @foreach (var item in _items2)
                {
                    <Draggable Item="item" OnDropped="@(e => Drag(_items2, item, e))" DragEffectAllowed="DragEffect.CopyMove">@item</Draggable>
                }
            </DropTarget>
        </div>
    </TitleContent>
    <ChildContent>
        @CodeFormatter.CodeToMarkup(@"<DropTarget TDropItem=""string"" Class=""flex-grow-1 align-self-stretch bg-alt p-2 rounded"" OnDrop=""@(e => Drop(_items1, e))"">
    <h6>Drop Target 1</h6>
    @foreach (var item in _items1)
    {
        <Draggable Item=""item"" OnDropped=""@(e => Drag(_items1, item, e))"" DragEffectAllowed=""DragEffect.CopyMove"">@item</Draggable>
    }
</DropTarget>
<DropTarget TDropItem=""string"" Class=""flex-grow-1 align-self-stretch bg-alt p-2 rounded ms-3"" OnDrop=""@(e => Drop(_items2, e))"">
    <h6>Drop Target 2</h6>
    @foreach (var item in _items2)
    {
        <Draggable Item=""item"" OnDropped=""@(e => Drag(_items2, item, e))"" DragEffectAllowed=""DragEffect.CopyMove"">@item</Draggable>
    }
</DropTarget>", true)
        <br>
        <pre>
<span class="pre-directive">&#64;code {</span>
    <span class="pre-element">private</span> <span class="pre-class">List</span><span class="pre-operator">&lt;</span><span class="pre-element">string</span><span class="pre-operator">></span> _items1 <span class="pre-operator">=</span> <span class="pre-element">new</span><span class="pre-operator">()</span>
    <span class="pre-operator">{</span>
        <span class="pre-string">"Drag this item"</span><span class="pre-operator">,</span>
        <span class="pre-string">"Or this one"</span><span class="pre-operator">,</span>
        <span class="pre-string">"Try dragging text into this box"</span><span class="pre-operator">,</span>
    <span class="pre-operator">};</span>
    <span class="pre-element">private</span> <span class="pre-class">List</span><span class="pre-operator">&lt;</span><span class="pre-element">string</span><span class="pre-operator">></span> _items2 <span class="pre-operator">=</span> <span class="pre-element">new</span><span class="pre-operator">()</span>
    <span class="pre-operator">{</span>
        <span class="pre-string">"Drag this item, too"</span><span class="pre-operator">,</span>
        <span class="pre-string">"Try dragging these items into a text editor"</span><span class="pre-operator">,</span>
    <span class="pre-operator">};</span>
    <span class="pre-element">private</span> <span class="pre-element">void</span> <span class="pre-method">Drag</span><span class="pre-operator">(</span><span class="pre-class">List</span><span class="pre-operator">&lt;</span><span class="pre-element">string</span><span class="pre-operator">></span> items<span class="pre-operator">,</span> <span class="pre-element">string</span> value<span class="pre-operator">,</span> <span class="pre-enum">DragEffect</span> e<span class="pre-operator">)</span>
    <span class="pre-operator">{</span>
        <span class="pre-element">if</span> <span class="pre-operator">(</span>e <span class="pre-operator">==</span> <span class="pre-enum">DragEffect</span><span class="pre-operator">.</span>Move<span class="pre-operator">)</span>
        <span class="pre-operator">{</span>
            items<span class="pre-operator">.</span><span class="pre-method">Remove</span><span class="pre-operator">(</span>value<span class="pre-operator">)</span><span class="pre-operator">;</span>
        <span class="pre-operator">}</span>
    <span class="pre-operator">}</span>
    <span class="pre-element">private</span> <span class="pre-element">void</span> <span class="pre-method">Drop</span><span class="pre-operator">(</span><span class="pre-class">List</span><span class="pre-operator">&lt;</span><span class="pre-element">string</span><span class="pre-operator">></span> items<span class="pre-operator">,</span> <span class="pre-class">DropEventArgs</span><span class="pre-operator">&lt;</span><span class="pre-element">string</span><span class="pre-operator">></span> e<span class="pre-operator">)</span>
        <span class="pre-operator">=></span> items<span class="pre-operator">.</span><span class="pre-method">Add</span><span class="pre-operator">(</span>e<span class="pre-operator">.</span>Data<span class="pre-operator">?.</span><span class="pre-method">FirstOrDefault</span><span class="pre-operator">().</span>Value <span class="pre-operator">??</span> <span class="pre-string">"Error"</span><span class="pre-operator">);</span>
<span class="pre-directive">}</span>
        </pre>
    </ChildContent>
</Collapse>

<Heading Level="HeadingLevel.H2">Draggable</Heading>

<p>
    The <code>Draggable</code> component can be used to represent any element which can be dragged.
    You can use it directly, with its <code>ChildContent</code> set to your actual markup, or you
    can subclass the component if you are building a reusable, draggable component of your own.
</p>

<p>
    The <code>Draggable</code> component has an <code>IsDraggable</code> property which determines
    whether it can currently be dragged. It is <code>true</code> by default. The
    <code>DragEffectAllowed</code> property controls what drag effects (copy, link and/or move) are
    permitted when dragging the item. All drag operations are allowed by default.
</p>

<p>
    The <code>Draggable</code> component is generic. Its <code>Item</code> property is expected to
    be set to an object which represents the data that is transferred during a drag operation.
    Alternatively, you can set the <code>GetDragData</code> property to a function which returns a
    <code>DragStartData</code> instance that more precisely defines the data to be dragged. This
    would allow you, for example, to explicitly set the list of fallback data types. When doing so,
    you may need to set the <code>TDragItem</code> generic type property to <code>object</code> (or
    some other type), to avoid compiler issues.
</p>

<p>
    You can set the <code>OnDropped</code> callback to determine what happens to an item when a drag
    event completes. Note that this callback will also be invoked when a drag ends by cancellation.
    You can determine the type of drag which occurred by checking the <code>DragEffect</code>
    parameter, which will always be one of <code>None</code>, <code>Copy</code>, <code>Link</code>,
    or <code>Move</code> (i.e. never one of the combined flags used to indicate allowed operations).
    Normally this is where you would remove the item from its current location if the effect was
    <code>Move</code>.
</p>

<p>
    If you subclass the <code>Draggable</code> component, be sure to set the <code>id</code>
    attribute of the main, draggable element in your HTML markup to the <code>Id</code> property,
    and set the <code>draggable</code> attribute to the <code>IsDraggable</code> property (or simply
    to <code>true</code> if your subclass will always be draggable).
</p>

<p>
    You can set the <code>DragClass</code> to a CSS class which will be set on the element during a
    drag operation, and cleared when the drag ends.
</p>

<Heading Level="HeadingLevel.H2">Drop Target</Heading>

<p>
    The <code>DropTarget</code> component can be used for any element onto which data can be
    dragged. You can use it directly, with its <code>ChildContent</code> set to your actual markup,
    or you can subclass the component if you are building a reusable, drop target component of your
    own.
</p>

<p>
    The <code>DropTarget</code> component has an <code>IsDropTarget</code> property which determines
    whether it will currently accept dropped data. It is <code>true</code> by default.
</p>

<p>
    Controlling what data a target accepts, and what type of drag operations it allows, can be
    complex. The <code>DropTarget</code> component is generic, and its <code>TDropItem</code> type
    parameter indicates the type of data it expects for data transferred internally, within the same
    Tavenem Blazor Framework app instance (typically the same browser tab). Data transferred from
    outside the app instance will always be a string. You can set the <code>TDropItem</code>
    type parameter to <code>string</code> to indicate that a drop target is intended for external
    dropped data.
</p>

<p>
    The <code>DropEffect</code> property can be set to indicate that a drop target only allows a
    particular type of drop. It can only be set to <code>All</code>, <code>Copy</code>,
    <code>Link</code>, or <code>Move</code> (i.e. never one of the combined flags used to indicate
    allowed drag operations). By default this is set to allow all drag operations. Note that
    <code>None</code> is not an option. To prevent all types of drag operations, set
    <code>IsDropTarget</code> to false.
</p>

<p>
    The <code>GetDropEffect</code> property can be set to a delegate which accepts the current drag
    data types, and should return a <code>DragEffect</code> which indicates the type of drop
    allowed. Valid return types are <code>None</code>, <code>All</code>, <code>Copy</code>,
    <code>Link</code>, or <code>Move</code> (i.e. none of the combined flags used to indicate
    allowed drag operations). If the item being dragged over the target was dragged from within the
    same Tavenem Blazor Framework app instance (typically the same browser tab), a second parameter
    will contain the actual item being dragged. This won't be the case for string data, including
    string data from within the Tavenem Blazor Framework, or any data from outside the app. For such
    data only the data types present can be used to determine the allowed drop effect.
</p>

<p>
    The <code>CanDrop</code> property can be set to a function which returns a boolean value to
    indicate whether data transferred within the same Tavenem Blazor Framework app instance
    (typically the same browser tab) can be dropped. This can be a useful shortcut for drop targets
    which <em>only</em> accept internally-transferred data, to avoid the complexity of the
    <code>GetDropEffect</code> delegate. Note that <code>CanDrop</code> is ignored if
    <code>GetDropEffect</code> has been set.
</p>

<p>
    The <code>OnDrop</code> property should be set to a callback which handles a drop event for the
    target. If this property is not set, the drop target will not accept any dragged data. This
    callback receives a <code>DropEventArgs</code> parameter with the dropped data and the final
    drag effect, and should perform whatever operation is appropriate for the data being dropped. Be
    sure to take the <code>DragEffect</code> into account, unless your target accepts only one kind.
</p>

<p>
    Note that your <code>OnDrop</code> callback should only perform the operations relevant to the
    drop target. Anything which may occur at the drag site should be handled by the
    <code>OnDropped</code> callback of the dragged item, for internal transfers, or by whatever
    logic was implemented at the callsite, for external transfers.
</p>

<p>
    You can set the <code>DropClass</code> to a CSS class which will be set on the element when a
    valid item is dragged over it, and cleared when the dragged item either leaves the target, or is
    dropped. You can also set the <code>NoDropClass</code> to a CSS class which will be set on the
    element for an <em>invalid</em> item. These classes both have defaults with appropriate visual
    indicators.
</p>

<Heading Level="HeadingLevel.H2">Draggable Drop Target</Heading>

<p>
    The <code>DraggableDropTarget</code> component represents a combination of
    <code>Draggable</code> and <code>DropTarget</code>, with all the properties of both. Use it when
    an item can both <em>be</em> dragged, and can have data dropped onto it.
</p>

@code {
    private List<string> _items1 = new()
    {
        "Drag this item",
        "Or this one",
        "Try dragging text into this box",
    };
    private List<string> _items2 = new()
    {
        "Drag this item, too",
        "Try dragging these items into a text editor",
    };
    private void Drag(List<string> items, string value, DragEffect e)
    {
        if (e == DragEffect.Move)
        {
            items.Remove(value);
        }
    }
    private void Drop(List<string> items, DropEventArgs<string> e)
        => items.Add(e.Data?.FirstOrDefault().Value ?? "Error");
}
